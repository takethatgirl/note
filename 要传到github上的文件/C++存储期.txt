决定存储期的关键字：auto register static extern mutable
存储期：标志符在内存中存在的时间。
全局变量（位于所有类和所有函数之外的变量）和static修饰的局部变量在整个程序运行期间一直存在，static修饰的局部变量必须定义时初始化，
int gloab;
使用全局变量前加::，即::gloab，可避免局部变量和全局变量重名引来的bug。
auto默认存储类别，修饰局部变量和函数形参，register修饰auto变量，存储于寄存器而非内存，编译器自行优化，程序员一般不需使用。
C++已经弃用auto和register关键字。auto 关键字用于两种情况：声明变量时根据初始化表达式自动推断该变量的类型、声明函数时函数返回值的占位符。
------------------------------------------------------------------------------------------------------- 
static的作用
（1）static修饰的局部变量定义时必须初始化，static修饰的局部变量所在的函数，多次调用，但是（2）static局部变量只被第一次初始化，剩余的调用是基于上一次函数运行结束后的值运行。static修饰的局部变量在整个程序结束后才销毁。
（3）全局变量能被工程的其他源文件访问（extern声明），但是static修饰的全局变量，仅本源文件具有可见性。
static修饰的全局函数同（2）.
（4）在类中，static修饰静态数据成员和静态函数。
        静态数据成员只有一份，为所有对象共享，一旦被修改，所有对象可见。程序开始运行时，已经        存在于内存，即使不创建对象，也已经存在和可调用，类名::
        静态成员函数不能调用非静态数据成员和非静态函数，不能有this指针。非静态函数可以调用静态        数据成员和静态成员函数。
-------------------------------------------------------------------------------------------------------
extern的作用
在B源文件，使用A源文件的变量和函数，可以在B源文件中声明此变量和函数，前加extern。
注意：在B文件不会检查变量类型和函数的形参列表，仅通过函数名和变量名判断。所以要小心编写。
------------------------------------------------------------------------------------------------------
#include <iostream>
#include <string.h>
using namespace std;
class A {
  char string[50];
public :
  A(char * st);
  ~A( );
};
A::A(char * st)
{ 
   strcpy(string, st);
   cout << string << "被创建时调用构造函数 ! " << endl;
}
A::~A( )
{  
    cout << string << 
    "被撤消时调用析构函数 ! " << endl;
}
 
 
void fun( )
{ 
    cout << "在fun( )函数体内 : \n" << endl; 
    A FunObj("fun( )函数体内的自动对象FunObj");
              
    static A InStaObj("内部静态对象InStaObj");
}
 
int main( )
{ 
    A MainObj("主函数体内的自动对象MainObj");
    cout<<"主函数体内，调用fun()函数前: \n";
    fun( );
    cout << "\n主函数体内，调用fun()函数后:\n";
    return 0;
}
 
static A ExStaObj("外部静态对象ExStaObj");
A GblObj("外部对象GblObj");

输出：
外部静态对象ExStaObj被创建时调用构造函数 ! 
外部对象GblObj被创建时调用构造函数 ! 
主函数体内的自动对象MainObj被创建时调用构造函数 ! 
主函数体内，调用fun()函数前: 
在fun( )函数体内 : 
 
fun( )函数体内的自动对象FunObj被创建时调用构造函数 ! 
内部静态对象InStaObj被创建时调用构造函数 ! 
fun( )函数体内的自动对象FunObj被撤消时调用析构函数 ! 
 
主函数体内，调用fun()函数后:
主函数体内的自动对象MainObj被撤消时调用析构函数 ! 
内部静态对象InStaObj被撤消时调用析构函数 ! 
外部对象GblObj被撤消时调用析构函数 ! 
外部静态对象ExStaObj被撤消时调用析构函数 !

分析：

创建顺序
外部静态对象or外部对象优先于main函数
销毁顺序
和创建顺序相反，注意静态对象会在main函数执行完才会销毁

从静态存储区分配：此时的内存在程序编译的时候已经分配好，并且在程序的整个运行期间都存在。全局变量，static变量等在此存储
堆和栈统称为动态存储区
在栈区分配：相关代码执行时创建，执行结束时被自动释放。局部变量在此存储。栈内存分配运算内置于处理器的指令集中，效率高，但容量有限
在堆区分配：动态分配内存。用new/malloc时开辟，delete/free时释放。生存期由用户指定，灵活。但有内存泄露等问题
------------------------------------------------------------------------------------------------------
