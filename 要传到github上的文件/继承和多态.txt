构成多态的条件：
1，基类中需要实现多态的函数用virtual修饰，即虚函数。
2，派生类覆盖时，函数名，函数列表都必须保持不变。返回类型，或者与基类虚函数的相同，或者都返回指针或引用，并且派生类虚函数所返回的指针或引用的基类型是基类中被替换的虚函数所返回的指针或引用的基类型的子类型。前加virtual，后加override。
3，基类指针指向派生类对象。
-------------------------------------------------------------------------------------------------------
多态的结果：
基类指针/基类引用指向派生类对象。
通过基类指针，调用从基类继承而来的非虚函数和未重写的虚函数以及派生类重写的虚函数。
基类指针向下转型得到的派生类指针，能调用派生类新增的函数。
-------------------------------------------------------------------------------------------------------
animal *a = new animal();//基类指针指向派生类对象。
Cat *c = dynamic_cast<Cat *>(a);//向下强制类型转换
typeid(*a).name();
delete(a);
dynamic_cast<>( )   向下强制类型转换，失败返回nullptr。
---------------------------------------------------------------
Animal &ac1 = Cat("mimi");
Cat *cat = dynamic_cast<Cat*>(&ac1);
-----------------------------------------------------------------
typeid( )返回一个type_info对象的引用，该对象含有操作数数据类型的信息。该对象的成员函数name，返回基于数组的字符串，表示数据类型名。
补充：
无法在派生类中，定义一个与从基类继承而来的函数同名的新函数，构成重载，这样只会隐藏从基类继承而来的同名函数。
只要派生类，含有与从基类继承而来的函数同名的函数，若是覆盖，则正常。如不构成覆盖，则是隐藏，即，一个指向派生类对象的基类指针无法调用之，一个指向派生类对象的派生类指针，只能严格按照派生类的同名函数的参数列表传参，因为隐藏了从基类那里继承而来的所有同名函数，若想调用从基类那里继承而来的函数，加基类名：：函数名（形参列表）。

class A  {
public :
	void f(int i) {
		cout << "AAA" << endl;
	}
};

class B : public A {
public:
    void f(int i)  {
		cout << "BBB" << endl;
	}
	
};
int main() {
	B b;
	b.f(3);
	b.A::f(3);
	system("pause");
	return 0;
}
打印结果：
BBB
AAA
---------------------------------------------------------------------------------------------------
class A  {
public :
	virtual void f(int i) {
		cout << "AAA" << endl;
	}
};

class B : public A {
public:
    void f(int i,double d)  {
		cout << "BBB" << endl;
	}
	
};

int main() {
	B b;
	A * a = &b;
	a->f(3);//AAA
	//a->f(3, 0.1);//error f(3,0.1)算是派生类的新函数
	system("pause");
	return 0;
}
--------------------------------------------------------------------------------------------------


 1，final修饰的virtual函数不能被重写。
class A {
    virtual void f( ) final {
    }
};
2，final修饰的类不能被继承。
class A final { };
---------------------------------------------------------------------------------------------------
纯虚函数
virtual void draw( ) const = 0;
纯虚函数不必实现。
含有纯虚函数的类叫抽象基类。
抽象基类不能实例化。
继承抽象基类的类若实现纯虚函数，则可实例化，否则派生类仍是抽象基类。
虽然抽象基类不能实例化，但是可以声明抽象基类的引用或指针，进行多态性操作。
--------------------------------------------------------------------------------------------------
优秀的面向对象系统的继承层次，前几层一般都是抽象基类。
抽象基类为派生类提供通用的抽象接口，减少向下转型的操作。