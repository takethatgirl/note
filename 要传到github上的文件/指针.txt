每个字节通过地址来标识。
相邻字节捆绑一起可以形成更大的字节，表示更大的范围。此时，捆绑字节的地址可以是第一个字节的地址，也可以是最后一个字节的地址，由编译器决定。
对float*进行间接访问将产生一个float型值。
操作变量其实就是操作存储单元的内容，有两种方式：
1，变量名   2，*存放变量地址的地址变量（即*变量地址）
地址变量的地址变量：int a；  int *b = &a； int **c = &b；   **c就是a。
int *a的含义：a变量存放一个int型变量的地址；*a可以访问一个int型的变量。
int **a的含义：a变量存放一个存放了一个int型变量的地址；*a  **a。
地址变量的运算：
1. 地址变量+ - 整数
  【原地址变量和结果地址变量只能存放数组中某个元素地址的地址变量或数组中最后一个元素后面的存储单元的地址且不能对其进行间接访问】
  【对地址变量+整数运算，结果地址变量存放了数组中最后一个元素后面的存储单元的地址是合法的，但不能对其进行间接访问；对地址变量 - 整数运算，结果地址变量存放了数组中第一个元素前面的存储单元的地址是非法的】
整数是变量的个数，不是字节的个数，结果地址 = 原地址 + 整数 * 类型字节数
2. 地址变量 - 地址变量    【两个地址变量存放的都是同一个数组中的元素的地址，结果是间隔变量数】
3. == 和 ！= 运算    【在任意的两个指针间执行相等或不相等测试，检测它们是否指向同一存储单元】
4. 关系运算 ：>  >=  <  <= 【两个指针指向同一个数组中的元素，比较表达式结果会告诉你哪个指针指向数组中更前或更后的元素，标准允许指向数组元素的指针与指向最后一个元素后面的那个内存位置的指针进行比较，但不允许与指向数组第一个元素之前的那个内存位置的指针进行比较】
警告！
向函数错误的传递NULL指针。
将一个数组初始化使其全为0
float values(N_VALUES);
float *vp;
for(vp = &values[0]; vp<&values(N_VALUES);)
    *vp++ = 0  ;
//正确
for ( vp = &values[N_VALUES]; vp > &values[0];)
    *--vp = 0 ;     
 //错误
NULL指针:
地址变量 = NULL；表示该地址变量不指向任何一个存储单元。
如何检测地址变量是否为NULL ?
if (地址变量 == 0)    地址变量为NULL。
对一个NULL地址变量进行间接访问，也是非法的。对NULL指针进行间接访问操作的后果因编译器而异，两个常见的后果分别是返回内存位置零的值以及终止程序。
风格良好的程序会在间接访问地址地址变量前对它进行检查，这种初始化策略可以节省大量的调试时间。
在你对地址变量进行间接访问之前，必须非常小心，确保他们已被初始化！
越界地址变量和指向未知值的地址变量是两个常见的错误根源。
